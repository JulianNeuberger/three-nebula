import * as Behaviour from '../behaviour';
import * as Initializer from '../initializer';
import { EULER, POOL_MAX } from '../constants';
import { INITIALIZER_TYPES_THAT_REQUIRE_THREE, SUPPORTED_JSON_BEHAVIOUR_TYPES, SUPPORTED_JSON_INITIALIZER_TYPES } from './constants';
import Rate from '../initializer/Rate';
/**
 * Makes a rate instance.
 *
 * @param {object} json - The data required to construct a Rate instance
 * @return {Rate}
 */

const makeRate = json => Rate.fromJSON(json);
/**
 * Makes initializers from json items.
 *
 * @param {array<object>} items - An array of objects which provide initializer constructor params
 * @param {object} THREE - The Web GL Api to use
 * @return {array<Initializer>}
 */


const makeInitializers = (items, THREE) => {
  const initializers = [];
  items.forEach(data => {
    const {
      type,
      properties
    } = data;

    if (!SUPPORTED_JSON_INITIALIZER_TYPES.includes(type)) {
      throw new Error(`The initializer type ${type} is invalid or not yet supported`);
    }

    if (INITIALIZER_TYPES_THAT_REQUIRE_THREE.includes(type)) {
      initializers.push(Initializer[type].fromJSON(properties, THREE));
    } else {
      initializers.push(Initializer[type].fromJSON(properties));
    }
  });
  return initializers;
};
/**
 * Makes behaviours from json items.
 *
 * @param {array<object>} items - An array of objects which provide behaviour constructor params
 * @return {array<Behaviour>}
 */


const makeBehaviours = items => {
  const behaviours = [];
  items.forEach(data => {
    const {
      type,
      properties
    } = data;

    if (!SUPPORTED_JSON_BEHAVIOUR_TYPES.includes(type)) {
      throw new Error(`The behaviour type ${type} is invalid or not yet supported`);
    }

    behaviours.push(Behaviour[type].fromJSON(properties));
  });
  return behaviours;
};
/**
 * Creates a System instance from a JSON object.
 *
 * @deprecated Use fromJSONAsync instead.
 *
 * @param {object} json - The JSON to create the System instance from
 * @param {object} THREE - The Web GL Api to use
 * @param {function} System - The system class
 * @param {function} Emitter - The emitter class
 * @param {number} json.preParticles - The predetermined number of particles
 * @param {string} json.integrationType - The integration algorithm to use
 * @param {array<object>} json.emitters - The emitters for the system instance
 * @return {System}
 */


export default ((json, THREE, System, Emitter) => {
  const {
    preParticles = POOL_MAX,
    integrationType = EULER,
    emitters = []
  } = json;
  const system = new System(THREE, preParticles, integrationType);
  emitters.forEach(data => {
    const emitter = new Emitter();
    const {
      rate,
      rotation,
      initializers,
      behaviours,
      emitterBehaviours = [],
      position,
      totalEmitTimes = Infinity,
      life = Infinity
    } = data;
    emitter.setRate(makeRate(rate)).setRotation(rotation).setInitializers(makeInitializers(initializers, THREE)).setBehaviours(makeBehaviours(behaviours)).setEmitterBehaviours(makeBehaviours(emitterBehaviours)).setPosition(position).emit(totalEmitTimes, life);
    system.addEmitter(emitter);
  });
  return system;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL2Zyb21KU09OLmpzIl0sIm5hbWVzIjpbIkJlaGF2aW91ciIsIkluaXRpYWxpemVyIiwiRVVMRVIiLCJQT09MX01BWCIsIklOSVRJQUxJWkVSX1RZUEVTX1RIQVRfUkVRVUlSRV9USFJFRSIsIlNVUFBPUlRFRF9KU09OX0JFSEFWSU9VUl9UWVBFUyIsIlNVUFBPUlRFRF9KU09OX0lOSVRJQUxJWkVSX1RZUEVTIiwiUmF0ZSIsIm1ha2VSYXRlIiwianNvbiIsImZyb21KU09OIiwibWFrZUluaXRpYWxpemVycyIsIml0ZW1zIiwiVEhSRUUiLCJpbml0aWFsaXplcnMiLCJmb3JFYWNoIiwiZGF0YSIsInR5cGUiLCJwcm9wZXJ0aWVzIiwiaW5jbHVkZXMiLCJFcnJvciIsInB1c2giLCJtYWtlQmVoYXZpb3VycyIsImJlaGF2aW91cnMiLCJTeXN0ZW0iLCJFbWl0dGVyIiwicHJlUGFydGljbGVzIiwiaW50ZWdyYXRpb25UeXBlIiwiZW1pdHRlcnMiLCJzeXN0ZW0iLCJlbWl0dGVyIiwicmF0ZSIsInJvdGF0aW9uIiwiZW1pdHRlckJlaGF2aW91cnMiLCJwb3NpdGlvbiIsInRvdGFsRW1pdFRpbWVzIiwiSW5maW5pdHkiLCJsaWZlIiwic2V0UmF0ZSIsInNldFJvdGF0aW9uIiwic2V0SW5pdGlhbGl6ZXJzIiwic2V0QmVoYXZpb3VycyIsInNldEVtaXR0ZXJCZWhhdmlvdXJzIiwic2V0UG9zaXRpb24iLCJlbWl0IiwiYWRkRW1pdHRlciJdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxLQUFLQSxTQUFaLE1BQTJCLGNBQTNCO0FBQ0EsT0FBTyxLQUFLQyxXQUFaLE1BQTZCLGdCQUE3QjtBQUVBLFNBQVNDLEtBQVQsRUFBZ0JDLFFBQWhCLFFBQWdDLGNBQWhDO0FBQ0EsU0FDRUMsb0NBREYsRUFFRUMsOEJBRkYsRUFHRUMsZ0NBSEYsUUFJTyxhQUpQO0FBTUEsT0FBT0MsSUFBUCxNQUFpQixxQkFBakI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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Q3VCLElBQUQsQ0FEbkIsRUFFR1EsV0FGSCxDQUVlUCxRQUZmLEVBR0dRLGVBSEgsQ0FHbUI3QixnQkFBZ0IsQ0FBQ0csWUFBRCxFQUFlRCxLQUFmLENBSG5DLEVBSUc0QixhQUpILENBSWlCbkIsY0FBYyxDQUFDQyxVQUFELENBSi9CLEVBS0dtQixvQkFMSCxDQUt3QnBCLGNBQWMsQ0FBQ1csaUJBQUQsQ0FMdEMsRUFNR1UsV0FOSCxDQU1lVCxRQU5mLEVBT0dVLElBUEgsQ0FPUVQsY0FQUixFQU93QkUsSUFQeEI7QUFTQVIsSUFBQUEsTUFBTSxDQUFDZ0IsVUFBUCxDQUFrQmYsT0FBbEI7QUFDRCxHQXZCRDtBQXlCQSxTQUFPRCxNQUFQO0FBQ0QsQ0FsQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBCZWhhdmlvdXIgZnJvbSAnLi4vYmVoYXZpb3VyJztcclxuaW1wb3J0ICogYXMgSW5pdGlhbGl6ZXIgZnJvbSAnLi4vaW5pdGlhbGl6ZXInO1xyXG5cclxuaW1wb3J0IHsgRVVMRVIsIFBPT0xfTUFYIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcclxuaW1wb3J0IHtcclxuICBJTklUSUFMSVpFUl9UWVBFU19USEFUX1JFUVVJUkVfVEhSRUUsXHJcbiAgU1VQUE9SVEVEX0pTT05fQkVIQVZJT1VSX1RZUEVTLFxyXG4gIFNVUFBPUlRFRF9KU09OX0lOSVRJQUxJWkVSX1RZUEVTLFxyXG59IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmltcG9ydCBSYXRlIGZyb20gJy4uL2luaXRpYWxpemVyL1JhdGUnO1xyXG5cclxuLyoqXHJcbiAqIE1ha2VzIGEgcmF0ZSBpbnN0YW5jZS5cclxuICpcclxuICogQHBhcmFtIHtvYmplY3R9IGpzb24gLSBUaGUgZGF0YSByZXF1aXJlZCB0byBjb25zdHJ1Y3QgYSBSYXRlIGluc3RhbmNlXHJcbiAqIEByZXR1cm4ge1JhdGV9XHJcbiAqL1xyXG5jb25zdCBtYWtlUmF0ZSA9IGpzb24gPT4gUmF0ZS5mcm9tSlNPTihqc29uKTtcclxuXHJcbi8qKlxyXG4gKiBNYWtlcyBpbml0aWFsaXplcnMgZnJvbSBqc29uIGl0ZW1zLlxyXG4gKlxyXG4gKiBAcGFyYW0ge2FycmF5PG9iamVjdD59IGl0ZW1zIC0gQW4gYXJyYXkgb2Ygb2JqZWN0cyB3aGljaCBwcm92aWRlIGluaXRpYWxpemVyIGNvbnN0cnVjdG9yIHBhcmFtc1xyXG4gKiBAcGFyYW0ge29iamVjdH0gVEhSRUUgLSBUaGUgV2ViIEdMIEFwaSB0byB1c2VcclxuICogQHJldHVybiB7YXJyYXk8SW5pdGlhbGl6ZXI+fVxyXG4gKi9cclxuY29uc3QgbWFrZUluaXRpYWxpemVycyA9IChpdGVtcywgVEhSRUUpID0+IHtcclxuICBjb25zdCBpbml0aWFsaXplcnMgPSBbXTtcclxuXHJcbiAgaXRlbXMuZm9yRWFjaChkYXRhID0+IHtcclxuICAgIGNvbnN0IHsgdHlwZSwgcHJvcGVydGllcyB9ID0gZGF0YTtcclxuXHJcbiAgICBpZiAoIVNVUFBPUlRFRF9KU09OX0lOSVRJQUxJWkVSX1RZUEVTLmluY2x1ZGVzKHR5cGUpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgVGhlIGluaXRpYWxpemVyIHR5cGUgJHt0eXBlfSBpcyBpbnZhbGlkIG9yIG5vdCB5ZXQgc3VwcG9ydGVkYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChJTklUSUFMSVpFUl9UWVBFU19USEFUX1JFUVVJUkVfVEhSRUUuaW5jbHVkZXModHlwZSkpIHtcclxuICAgICAgaW5pdGlhbGl6ZXJzLnB1c2goSW5pdGlhbGl6ZXJbdHlwZV0uZnJvbUpTT04ocHJvcGVydGllcywgVEhSRUUpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGluaXRpYWxpemVycy5wdXNoKEluaXRpYWxpemVyW3R5cGVdLmZyb21KU09OKHByb3BlcnRpZXMpKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIGluaXRpYWxpemVycztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNYWtlcyBiZWhhdmlvdXJzIGZyb20ganNvbiBpdGVtcy5cclxuICpcclxuICogQHBhcmFtIHthcnJheTxvYmplY3Q+fSBpdGVtcyAtIEFuIGFycmF5IG9mIG9iamVjdHMgd2hpY2ggcHJvdmlkZSBiZWhhdmlvdXIgY29uc3RydWN0b3IgcGFyYW1zXHJcbiAqIEByZXR1cm4ge2FycmF5PEJlaGF2aW91cj59XHJcbiAqL1xyXG5jb25zdCBtYWtlQmVoYXZpb3VycyA9IGl0ZW1zID0+IHtcclxuICBjb25zdCBiZWhhdmlvdXJzID0gW107XHJcblxyXG4gIGl0ZW1zLmZvckVhY2goZGF0YSA9PiB7XHJcbiAgICBjb25zdCB7IHR5cGUsIHByb3BlcnRpZXMgfSA9IGRhdGE7XHJcblxyXG4gICAgaWYgKCFTVVBQT1JURURfSlNPTl9CRUhBVklPVVJfVFlQRVMuaW5jbHVkZXModHlwZSkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBUaGUgYmVoYXZpb3VyIHR5cGUgJHt0eXBlfSBpcyBpbnZhbGlkIG9yIG5vdCB5ZXQgc3VwcG9ydGVkYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGJlaGF2aW91cnMucHVzaChCZWhhdmlvdXJbdHlwZV0uZnJvbUpTT04ocHJvcGVydGllcykpO1xyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gYmVoYXZpb3VycztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgU3lzdGVtIGluc3RhbmNlIGZyb20gYSBKU09OIG9iamVjdC5cclxuICpcclxuICogQGRlcHJlY2F0ZWQgVXNlIGZyb21KU09OQXN5bmMgaW5zdGVhZC5cclxuICpcclxuICogQHBhcmFtIHtvYmplY3R9IGpzb24gLSBUaGUgSlNPTiB0byBjcmVhdGUgdGhlIFN5c3RlbSBpbnN0YW5jZSBmcm9tXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBUSFJFRSAtIFRoZSBXZWIgR0wgQXBpIHRvIHVzZVxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBTeXN0ZW0gLSBUaGUgc3lzdGVtIGNsYXNzXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IEVtaXR0ZXIgLSBUaGUgZW1pdHRlciBjbGFzc1xyXG4gKiBAcGFyYW0ge251bWJlcn0ganNvbi5wcmVQYXJ0aWNsZXMgLSBUaGUgcHJlZGV0ZXJtaW5lZCBudW1iZXIgb2YgcGFydGljbGVzXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBqc29uLmludGVncmF0aW9uVHlwZSAtIFRoZSBpbnRlZ3JhdGlvbiBhbGdvcml0aG0gdG8gdXNlXHJcbiAqIEBwYXJhbSB7YXJyYXk8b2JqZWN0Pn0ganNvbi5lbWl0dGVycyAtIFRoZSBlbWl0dGVycyBmb3IgdGhlIHN5c3RlbSBpbnN0YW5jZVxyXG4gKiBAcmV0dXJuIHtTeXN0ZW19XHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCAoanNvbiwgVEhSRUUsIFN5c3RlbSwgRW1pdHRlcikgPT4ge1xyXG4gIGNvbnN0IHtcclxuICAgIHByZVBhcnRpY2xlcyA9IFBPT0xfTUFYLFxyXG4gICAgaW50ZWdyYXRpb25UeXBlID0gRVVMRVIsXHJcbiAgICBlbWl0dGVycyA9IFtdLFxyXG4gIH0gPSBqc29uO1xyXG4gIGNvbnN0IHN5c3RlbSA9IG5ldyBTeXN0ZW0oVEhSRUUsIHByZVBhcnRpY2xlcywgaW50ZWdyYXRpb25UeXBlKTtcclxuXHJcbiAgZW1pdHRlcnMuZm9yRWFjaChkYXRhID0+IHtcclxuICAgIGNvbnN0IGVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xyXG4gICAgY29uc3Qge1xyXG4gICAgICByYXRlLFxyXG4gICAgICByb3RhdGlvbixcclxuICAgICAgaW5pdGlhbGl6ZXJzLFxyXG4gICAgICBiZWhhdmlvdXJzLFxyXG4gICAgICBlbWl0dGVyQmVoYXZpb3VycyA9IFtdLFxyXG4gICAgICBwb3NpdGlvbixcclxuICAgICAgdG90YWxFbWl0VGltZXMgPSBJbmZpbml0eSxcclxuICAgICAgbGlmZSA9IEluZmluaXR5LFxyXG4gICAgfSA9IGRhdGE7XHJcblxyXG4gICAgZW1pdHRlclxyXG4gICAgICAuc2V0UmF0ZShtYWtlUmF0ZShyYXRlKSlcclxuICAgICAgLnNldFJvdGF0aW9uKHJvdGF0aW9uKVxyXG4gICAgICAuc2V0SW5pdGlhbGl6ZXJzKG1ha2VJbml0aWFsaXplcnMoaW5pdGlhbGl6ZXJzLCBUSFJFRSkpXHJcbiAgICAgIC5zZXRCZWhhdmlvdXJzKG1ha2VCZWhhdmlvdXJzKGJlaGF2aW91cnMpKVxyXG4gICAgICAuc2V0RW1pdHRlckJlaGF2aW91cnMobWFrZUJlaGF2aW91cnMoZW1pdHRlckJlaGF2aW91cnMpKVxyXG4gICAgICAuc2V0UG9zaXRpb24ocG9zaXRpb24pXHJcbiAgICAgIC5lbWl0KHRvdGFsRW1pdFRpbWVzLCBsaWZlKTtcclxuXHJcbiAgICBzeXN0ZW0uYWRkRW1pdHRlcihlbWl0dGVyKTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIHN5c3RlbTtcclxufTtcclxuIl19